# ADR-001: The Agentic Notification Protocol (ANP)

| Metadata    | Value             |
| :---------- | :---------------- |
| **Status**  | Accepted          |
| **Date**    | 2025-12-31        |
| **Context** | Core Event System |
| **Authors** | Lead Architect    |

## 1. Context

In building the Modular Media Control Plane (MMCP), we faced a critical friction point between the **System Control Plane** (deterministic reliability) and the **Agent Runtime** (adaptive personality).

Traditional notification systems (Pub/Sub, WebSockets) are insufficient because:

1.  **The "Nagging" Problem:** If the System shows a UI toast and the Agent also vocalizes it, the user receives double-notifications.
2.  **The "Amnesia" Problem:** If the System shows a UI toast but the Agent isn't informed, the Agent cannot answer follow-up questions ("Why did that download fail?").
3.  **The "Lost Data" Problem:** If we rely solely on the Agent to deliver notifications (`Handler=AGENT`), and the Agent crashes or hallucinates, critical system alerts (e.g., "Disk Full") are lost.

We needed a protocol that guarantees **Reliable Delivery** while maintaining **Shared Awareness** between the User and the Agent, without redundant signaling.

## 2. Decision

We have decided to implement the **Agentic Notification Protocol (ANP)**, a strict routing layer based on the principle of **Channel Monopoly** and three immutable semantic axes that define protocol-level guarantees independent of optional UI rendering.

### 2.1. The Three Immutable Semantic Axes

ANP uses three protocol-level flags that form a 3-axis semantic model. These axes are **immutable protocol guarantees**, independent of optional UI rendering:

- **Address (Spatial Boundary):** Defines the persistence scope of the notification.

  - `SESSION`: Bound to a specific `session_id` (conversational context).
  - `USER`: Bound to a `user_id` (global session state, independent of active conversations).

- **Target (Initial Receiver):** Defines who initially receives the event and has contextual responsibility.

  - `USER`: The Human is the Target. Protocol guarantees routing to a user-observable channel (UI). System channels are **deterministic**—they deliver immediately without agent intervention.
  - `AGENT`: The Agent is the Target. Protocol routes to the Agent's internal context. Agent channels are **autonomous**—the agent may veto, internal turn, or decide whether to notify the human.

- **Handler (Processing Responsibility):** Defines the entity responsible for processing or presenting the event.
  - `SYSTEM`: The System handles the message deterministically (Toast/Pill/History). This is a **protocol guarantee**—delivery is immediate and reliable. The Agent may still receive the event for awareness (read-only context), but does not process it.
  - `AGENT`: The Agent handles the message autonomously (Speech/Tool Calls). This is an **autonomous decision**—the agent may act, decide, or narrate to the human. The System suppresses raw delivery and renders the Agent's output instead.

**Protocol Purity:** These axes replace legacy flags (`scope`, `visibility`, `interaction`) to enforce clear separation between routing semantics and implementation details. All notifications that reach ANP are considered actionable; background polling or progress should be handled via **Context Providers**, not protocol-level timing flags.

### 2.2. The Channel Monopoly Principle

A notification is assigned to exactly **one** primary delivery channel at the moment of emission. It remains the responsibility of that channel until successful delivery is verified. Each notification is subject to **lease-based ownership fencing** to prevent concurrent delivery attempts.

Channels are classified by their **deterministic** vs **autonomous** behavior:

- **Channel A (Notification Inbox) - Deterministic:**

  - _Route:_ `Address=USER` + `Handler=SYSTEM`.
  - _Protocol Behavior:_ Immediate delivery without agent intervention. System channels are deterministic and reliable.
  - _UI Advisory (Optional):_ Red Dot / Bell Icon. Ephemeral toast may appear based on implementation hints.

- **Channel B (Conversation Floor) - Deterministic:**

  - _Route:_ `Address=SESSION` + `Handler=SYSTEM` + `Target=USER`.
  - _Protocol Behavior:_ Immediate injection into chat history. System channels are deterministic and reliable.
  - _UI Advisory (Optional):_ System Pill in Chat. Chat bubble or inline message.

- **Channel C (Agent Context) - Autonomous:**
  - _Route:_ (`Handler=AGENT`) **OR** (`Target=AGENT`).
  - _Protocol Behavior:_ Autonomous agent handling—the agent may veto, create an internal turn, or decide whether to notify the human. Agent channels are autonomous and may vary in delivery timing.
  - _UI Advisory (Optional):_ None initially. Agent may choose to generate chat bubbles, tool calls, or remain silent.

**Key Distinction:** Deterministic channels (SYSTEM) guarantee immediate, reliable delivery. Autonomous channels (AGENT) allow agent-mediated decision-making, with protocol-level escalation guarantees when EXTERNAL tools are invoked.

### 2.3. Decoupling Delivery from Awareness

We distinguish between "Who Speaks" (Delivery) and "Who Knows" (Awareness).

- **Delivery:** Controlled by the `Handler` axis. Only the assigned channel owner "Speaks" (renders UI or vocalizes text).
- **Awareness:** The non-speaking entity is updated passively.
  - _If System Speaks (`Handler=SYSTEM`):_ The Agent receives the event in its Prompt context marked as `[SEEN]` for read-only awareness.
  - _If Agent Speaks (`Handler=AGENT`):_ The UI renders the Agent's message but suppresses the raw system toast.

**Protocol Guarantee:** UI manifestation is advisory only. The protocol ensures delivery and agent awareness, but how notifications are rendered (toast, pill, chat) may vary by implementation. The distinction between **deterministic system delivery** and **autonomous agent narration** is enforced at the protocol level.

### 2.4. The Internal Turn with Safety Escalation

To support `Target=AGENT` + `Handler=AGENT` notifications, we allow the Agent Runtime to execute **Internal Turns** (non-UI, optionally actionable, fully auditable turns with no user-visible output).

**Internal vs External Tool Semantics:**

- **INTERNAL:** Agent may act without notifying the user; all actions are logged for auditability. Read-only operations, internal reasoning, memory queries. These do NOT trigger promotion to USER.
- **EXTERNAL:** Any action must be made visible to the user. The **protocol ensures mandatory promotion to USER**, even if the agent is executing autonomously. State-modifying operations with user-visible consequences. These DO trigger promotion to USER.

**Protocol Constraint:** The agent does not know the classification; it is strictly a protocol-level enforcement. If the Agent executes any tool classified as `EXTERNAL` during an Internal Turn, the protocol automatically promotes `Target` to **USER** to ensure auditability. This is **hard protocol behavior**—implementation may vary in UI rendering, but user awareness is guaranteed.

**Directive Field Semantics:** The `directive` field is a string containing instructions for the LLM during autonomous agent handling. This field provides context-specific guidance to help the agent decide how to process or present the notification.

## 3. Consequences

### Positive

- **Zero Redundancy:** Users will never receive a Toast and a Chat Message for the same event simultaneously.
- **Guaranteed Delivery:** Events with `Handler=SYSTEM` bypass the LLM entirely, ensuring critical alerts work even if the AI is offline. The protocol guarantees immediate dispatch when assigned to deterministic channels.
- **Shared Context:** Agents can answer questions about system toasts because the data is persisted in the `event_ledger` and hydrated into their context window.
- **Lightweight Idle:** Broadcast events (Channel A) do not trigger LLM inference. The Agent receives an ambient digest (one-sentence summary) to maintain situational awareness without prompt bloat.
- **Protocol Purity:** All notifications that reach ANP are considered actionable. Timing hints (urgency) may be used by implementations for UI rendering, but the protocol guarantees immediate dispatch for deterministic channels. Background polling or progress should be handled via Context Providers, not protocol-level flags.

### Negative

- **Complexity:** The Event Bus logic is significantly more complex than a standard WebSocket emitter. It requires a hardened state machine (`PENDING` -> `DISPATCHED` -> `LOCKED` -> `DELIVERED|ESCALATED|FAILED`) with lease-based ownership fencing to prevent race conditions.
- **Strictness:** Plugin developers must understand the difference between `Handler=SYSTEM` and `Handler=AGENT`, and the implications of `Target=USER` vs `Target=AGENT`. Misuse can lead to silent agents or "dumb" behavior.
- **Latency:** Agent-mediated notifications (`Handler=AGENT`) incur LLM inference latency.
- **Tool Classification Requirement:** Plugin tools must declare impact metadata (`INTERNAL` vs `EXTERNAL`) for Internal Turn promotion logic. The agent cannot determine this classification itself; it is a protocol-level constraint.

## 4. Alternatives Rejected

### 4.1. The "Double Broadcast" Model

- _Idea:_ Send everything to the UI _and_ the Agent simultaneously.
- _Rejection:_ Resulted in immediate "Nagging." The user would see a "Download Finished" toast, and 2 seconds later the Agent would type "Your download is finished."

### 4.2. The "Agent Filter" Model

- _Idea:_ Send everything to the Agent, and let the Agent decide what to show the user.
- _Rejection:_ This creates a Single Point of Failure. If the LLM service (LiteLLM/Ollama) is down or hallucinating, critical system alerts (e.g., "Server Overheating") would be swallowed.

### 4.3. The "Separate Systems" Model

- _Idea:_ One system for Logs, one system for Chat.
- _Rejection:_ Created "Agent Amnesia." The Agent had no knowledge of system events, destroying the illusion of a unified "Butler" persona.

## 5. State Machine & Escalation

ANP defines a strict state machine for compliance auditing within the `event_ledger`. State transitions are atomic and enforce ownership fencing to prevent race conditions.

### 5.1. State Transitions

The protocol enforces the following ordered transitions:

```
PENDING → DISPATCHED → LOCKED → (DELIVERED | ESCALATED → (DELIVERED | FAILED) | FAILED)
```

**States:**

1. **PENDING:** Event accepted by the Event Bus. Not yet routed to any channel.
2. **DISPATCHED:**
   - _System Channel:_ Payload sent via WebSocket.
   - _Agent Channel:_ Payload injected into System Prompt.
3. **LOCKED:** A transient state where either the **Agent Runtime** or the **Watchdog** has claimed ownership via a `lease_id`. This prevents concurrent delivery attempts.
4. **DELIVERED:**
   - _System Channel:_ Client sent `ACK` (Rendered/Clicked).
   - _Agent Channel:_ Agent returned notification ID in `acknowledged_ids`.
   - _Escalation Path:_ After escalation, successful System delivery transitions to this state.
5. **ESCALATED:** Agent execution failed or exceeded TTL; ownership forcibly reverted to System Channel (Fallback). After escalation, the event is re-routed to System channels (Channel A or B) and may transition to `DELIVERED` upon successful system delivery, or to `FAILED` if system delivery also fails.
6. **FAILED:** A terminal "Dead Letter" state used if both Agent delivery and System escalation fail (e.g., UI disconnected, network failure). Events in this state are logged for administrative review.

**Terminal States:** `DELIVERED` and `FAILED` are immutable terminal states. Once an event reaches either state, no further state transitions are permitted. `ESCALATED` is a transitional state that represents the fallback from Agent handling to System handling; it may progress to `DELIVERED` (successful system delivery) or `FAILED` (system delivery failure).

### 5.2. Internal Turn Escalation

When an Internal Turn escalates (via `EXTERNAL` tool invocation or TTL expiration), the protocol triggers **Target promotion to USER**. This is **hard protocol behavior**—implementation may vary in UI rendering, but user awareness is guaranteed. The state machine transitions through `LOCKED` (with incremented `owner_lease`) to `ESCALATED`, then re-routes to a deterministic channel (Channel A or B) based on `Address`. Note that `EXTERNAL` tool invocation during Internal Turns causes immediate Target promotion, while TTL expiration causes escalation through the `ESCALATED` state.

### 5.3. Deduplication & Idempotency

The `deduplication_key` applies across **all channels** and is independent of Target/Handler. When a notification with a `deduplication_key` matches an existing event in `PENDING` or `DISPATCHED` state, the existing event's content and metadata are overwritten. Key resets must respect **lease-based ownership**—if an event is `LOCKED`, deduplication updates must verify the current `owner_lease` to prevent race conditions.

## 6. Conceptual Mapping Table

The following matrix shows how the three semantic axes (Address × Target × Handler) map to channel routing, protocol behavior, and UI advisory:

| Address  | Target    | Handler   | Channel   | Protocol Behavior              | UI Advisory (Optional)                                   | Agent Awareness                     |
| :------- | :-------- | :-------- | :-------- | :----------------------------- | :------------------------------------------------------- | :---------------------------------- |
| **USER** | **USER**  | **SYS**   | Channel A | Deterministic: Inbox Delivery  | Red Dot / Bell Icon. Ephemeral toast.                    | Ambient Awareness (Ledger).         |
| **SESS** | **USER**  | **SYS**   | Channel B | Deterministic: History Inject  | System Pill in Chat. Chat bubble.                        | Read-Only (Historical Fact).        |
| **USER** | **USER**  | **AGENT** | Channel C | Autonomous: Agent must narrate | Agent-Authored Toast. Narrated text. High-urgency push.  | Immediate Narration (Must process). |
| **SESS** | **USER**  | **AGENT** | Channel C | Autonomous: Agent must narrate | Agent-Authored Turn. Immediate conversation bubble.      | Immediate Narration (Must process). |
| **SESS** | **AGENT** | **SYS**   | Channel C | Deterministic: Passive Context | None. Human is blind to the event.                       | Passive Context (Read-Only).        |
| **USER** | **AGENT** | **SYS**   | Channel C | Deterministic: Passive Context | None. Human is blind to the event.                       | Passive Context (Read-Only).        |
| **SESS** | **AGENT** | **AGENT** | Channel C | Autonomous: Agent decides      | None initially. Agent may internal turn, speak, or veto. | Immediate Processing (Actionable).  |
| **USER** | **AGENT** | **AGENT** | Channel C | Autonomous: Agent decides      | None initially. Agent may internal turn, speak, or veto. | Immediate Processing (Actionable).  |

**Legend:** SYS = SYSTEM, SESS = SESSION

This matrix ensures that future developers immediately understand the routing semantics and protocol guarantees for each axis combination.

## 7. Implementation Strategy

- **Database:** Single `system_events` table (SQLite) acts as the ledger. Includes `owner_lease` field for atomic compare-and-swap operations to enforce ownership fencing. The `deduplication_key` field enables cross-channel deduplication.
- **Runtime:** `AgentAwarenessMiddleware` injects `[SEEN]` events into the System Prompt. For Channel A (Inbox), injects ambient digest (one-sentence summary) instead of full event list. The runtime enforces Internal Turn escalation when `EXTERNAL` tools are invoked.
- **UI:** WebSocket protocol must support `ACK` signals to transition events from `DISPATCHED` to `DELIVERED`. System alerts are serialized before Agent turns to ensure causal ordering. UI rendering is advisory—the protocol ensures delivery, but implementation may vary (toast, pill, chat).
- **Tool Classification:** Plugin tools must declare impact metadata (`INTERNAL` vs `EXTERNAL`) for Internal Turn promotion logic. The agent does not know this classification; it is a protocol-level constraint enforced by the Event Bus.
- **Directive Field:** The `agent_instructions.directive` field is a string containing instructions for the LLM during autonomous agent handling.
